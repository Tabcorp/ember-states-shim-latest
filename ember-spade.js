var define, requireModule;

(function() {
  var registry = {}, seen = {};

  define = function(name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  requireModule = function(name) {
    if (seen[name]) { return seen[name]; }
    seen[name] = {};

    var mod, deps, callback, reified , exports;

    mod = registry[name];

    if (!mod) {
      throw new Error("Module '" + name + "' not found.");
    }

    deps = mod.deps;
    callback = mod.callback;
    reified = [];
    exports;

    for (var i=0, l=deps.length; i<l; i++) {
      if (deps[i] === 'exports') {
        reified.push(exports = {});
      } else {
        reified.push(requireModule(deps[i]));
      }
    }

    var value = callback.apply(this, reified);
    return seen[name] = exports || value;
  };
})();
minispade.register('ember-states', "(function() {/**\nEmber States\n\n@module ember\n@submodule ember-states\n@requires ember-runtime\n*/\nminispade.require('ember-states/state_manager');\nminispade.require('ember-states/state');\n\n})();\n//@ sourceURL=ember-states");minispade.register('ember-states/state', "(function() {var get = Ember.get, set = Ember.set;\n\n/**\n@module ember\n@submodule ember-states\n*/\n\n/**\n  The State class allows you to define individual states within a finite state machine\n  inside your Ember application.\n\n  ### How States Work\n\n  When you setup a finite state machine this means you are setting up a mechanism to precisely\n  manage the change within a system. You can control the various states or modes that your \n  application can be in at any given time. Additionally, you can manage what specific states \n  are allowed to transition to other states.\n\n  The state machine is in only one state at a time. This state is known as the current state. \n  It is possible to change from one state to another by a triggering event or condition. \n  This is called a transition. \n\n  Finite state machines are important because they allow the application developer to be \n  deterministic about the the sequence of events that can happen within a system. Some states\n  cannot be entered when the application is a given state.\n\n  For example:\n\n  A door that is in the `locked` state cannot be `opened` (you must transition to the `unlocked`\n  state first).\n\n  A door that is in the `open` state cannot be `locked` (you must transition to the `closed` \n  state first).\n\n\n  Each state instance has the following characteristics:\n\n  - Zero or more parent states\n  - A start state\n  - A name\n  - A path (a computed value that prefixes parent states and the complete hierarchy to itself ) \n\n  A state is known as a \"leafState\" when it is the last item on the path and has no children\n  beneath it. \n\n  The isLeaf property returns a boolean.\n\n  Each state can emit the following transition events\n\n  - setup\n  - enter\n  - exit\n\n  A state object is ususally created in the context of a state manager.\n\n  ```javascript\n  doorStateManager = Ember.StateManager.create({\n    locked: Ember.State.create(),\n    closed: Ember.State.create(),\n    unlocked: Ember.State.create(),\n    open: Ember.State.create()\n  });\n  ```\n \n  @class State\n  @namespace Ember\n  @extends Ember.Object\n  @uses Ember.Evented\n*/\nEmber.State = Ember.Object.extend(Ember.Evented,\n/** @scope Ember.State.prototype */{\n  /**\n    A reference to the parent state.\n\n    @property parentState\n    @type Ember.State\n  */\n  parentState: null,\n  start: null,\n\n  /**\n    The name of this state.\n\n    @property name\n    @type String\n  */\n  name: null,\n\n  /**\n    The full path to this state.\n\n    @property path\n    @type String\n  */\n  path: Ember.computed(function() {\n    var parentPath = get(this, 'parentState.path'),\n        path = get(this, 'name');\n\n    if (parentPath) {\n      path = parentPath + '.' + path;\n    }\n\n    return path;\n  }),\n\n  /**\n    @private\n\n    Override the default event firing from `Ember.Evented` to\n    also call methods with the given name.\n\n    @method trigger\n    @param name\n  */\n  trigger: function(name) {\n    if (this[name]) {\n      this[name].apply(this, [].slice.call(arguments, 1));\n    }\n    this._super.apply(this, arguments);\n  },\n\n  /**\n    Initialize Ember.State object\n    Sets childStates to Ember.NativeArray\n    Sets eventTransitions to empty object unless already defined.\n    Loops over properties of this state and ensures that any property that\n    is an instance of Ember.State is moved to `states` hash.\n  \n\n    @method init\n  */\n  init: function() {\n    var states = get(this, 'states');\n    set(this, 'childStates', Ember.A());\n    set(this, 'eventTransitions', get(this, 'eventTransitions') || {});\n\n    var name, value, transitionTarget;\n\n    // As a convenience, loop over the properties\n    // of this state and look for any that are other\n    // Ember.State instances or classes, and move them\n    // to the `states` hash. This avoids having to\n    // create an explicit separate hash.\n\n    if (!states) {\n      states = {};\n\n      for (name in this) {\n        if (name === \"constructor\") { continue; }\n\n        if (value = this[name]) {\n          if (transitionTarget = value.transitionTarget) {\n            this.eventTransitions[name] = transitionTarget;\n          }\n\n          this.setupChild(states, name, value);\n        }\n      }\n\n      set(this, 'states', states);\n    } else {\n      for (name in states) {\n        this.setupChild(states, name, states[name]);\n      }\n    }\n\n    // pathsCaches is a nested hash of the form:\n    //   pathsCaches[stateManagerTypeGuid][path] == transitions_hash\n    set(this, 'pathsCaches', {});\n  },\n\n  /**\n    Sets a cached instance of the state. Ember.guidFor is used\n    to find the guid of the associated state manager. If a cache can be found \n    the state path is added to that cache, otherwise an empty JavaScript object \n    is created. And the state path is appended to that instead. \n\n    @method setPathsCache\n    @param stateManager\n    @param path\n    @param transitions\n  */\n  setPathsCache: function(stateManager, path, transitions) {\n    var stateManagerTypeGuid = Ember.guidFor(stateManager.constructor),\n      pathsCaches = get(this, 'pathsCaches'),\n      pathsCacheForManager = pathsCaches[stateManagerTypeGuid] || {};\n\n    pathsCacheForManager[path] = transitions;\n    pathsCaches[stateManagerTypeGuid] = pathsCacheForManager;\n  },\n\n  /**\n    Returns a cached path for the state instance. Each state manager \n    has a GUID and this is used to look up a cached path if it has already\n    been created. If a cached path is not found an empty JavaScript object\n    is returned instead.\n\n    @method getPathsCache\n    @param stateManager\n    @param path\n  */\n  getPathsCache: function(stateManager, path) {\n    var stateManagerTypeGuid = Ember.guidFor(stateManager.constructor),\n      pathsCaches = get(this, 'pathsCaches'),\n      pathsCacheForManager = pathsCaches[stateManagerTypeGuid] || {};\n\n    return pathsCacheForManager[path];\n  },\n\n  /**\n    @private\n  \n    Create the child instance and ensure that it is an instance of Ember.State\n\n    @method setupChild\n    @param states\n    @param name\n    @param value\n  */\n  setupChild: function(states, name, value) {\n    if (!value) { return false; }\n    var instance;\n\n    if (value instanceof Ember.State) {\n      set(value, 'name', name);\n      instance = value;\n      instance.container = this.container;\n    } else if (Ember.State.detect(value)) {\n      instance = value.create({\n        name: name,\n        container: this.container\n      });\n    }\n\n    if (instance instanceof Ember.State) {\n      set(instance, 'parentState', this);\n      get(this, 'childStates').pushObject(instance);\n      states[name] = instance;\n      return instance;\n    }\n  },\n\n  /**\n    @private\n  \n    @method lookupEventTransition\n    @param name\n  */\n  lookupEventTransition: function(name) {\n    var path, state = this;\n\n    while(state && !path) {\n      path = state.eventTransitions[name];\n      state = state.get('parentState');\n    }\n\n    return path;\n  },\n\n  /**\n    A Boolean value indicating whether the state is a leaf state\n    in the state hierarchy. This is `false` if the state has child\n    states; otherwise it is true.\n\n    @property isLeaf\n    @type Boolean\n  */\n  isLeaf: Ember.computed(function() {\n    return !get(this, 'childStates').length;\n  }),\n\n  /**\n    A boolean value indicating whether the state takes a context.\n    By default we assume all states take contexts.\n\n    @property hasContext\n    @default true\n  */\n  hasContext: true,\n\n  /**\n    This is the default transition event.\n\n    @event setup\n    @param {Ember.StateManager} manager\n    @param context\n    @see Ember.StateManager#transitionEvent\n  */\n  setup: Ember.K,\n\n  /**\n    This event fires when the state is entered.\n\n    @event enter\n    @param {Ember.StateManager} manager\n  */\n  enter: Ember.K,\n\n  /**\n    This event fires when the state is exited.\n\n    @event exit\n    @param {Ember.StateManager} manager\n  */\n  exit: Ember.K\n});\n\nEmber.State.reopenClass({\n\n  /**\n    Creates an action function for transitioning to the named state while\n    preserving context.\n\n    The following example StateManagers are equivalent:\n\n    ```javascript\n    aManager = Ember.StateManager.create({\n      stateOne: Ember.State.create({\n        changeToStateTwo: Ember.State.transitionTo('stateTwo')\n      }),\n      stateTwo: Ember.State.create({})\n    })\n\n    bManager = Ember.StateManager.create({\n      stateOne: Ember.State.create({\n        changeToStateTwo: function(manager, context) {\n          manager.transitionTo('stateTwo', context)\n        }\n      }),\n      stateTwo: Ember.State.create({})\n    })\n    ```\n\n    @method transitionTo\n    @static\n    @param {String} target\n  */\n\n  transitionTo: function(target) {\n\n    var transitionFunction = function(stateManager, contextOrEvent) {\n      var contexts = [],\n          Event = Ember.$ && Ember.$.Event;\n\n      if (contextOrEvent && (Event && contextOrEvent instanceof Event)) {\n        if (contextOrEvent.hasOwnProperty('contexts')) {\n          contexts = contextOrEvent.contexts.slice();\n        }\n      }\n      else {\n        contexts = [].slice.call(arguments, 1);\n      }\n\n      contexts.unshift(target);\n      stateManager.transitionTo.apply(stateManager, contexts);\n    };\n\n    transitionFunction.transitionTarget = target;\n\n    return transitionFunction;\n  }\n\n});\n\n})();\n//@ sourceURL=ember-states/state");minispade.register('ember-states/state_manager', "(function() {/**\n@module ember\n@submodule ember-states\n*/\n\nvar get = Ember.get, set = Ember.set, fmt = Ember.String.fmt;\nvar arrayForEach = Ember.ArrayPolyfills.forEach;\nminispade.require('ember-states/state');\n\n/**\n  A Transition takes the enter, exit and resolve states and normalizes\n  them:\n\n  * takes any passed in contexts into consideration\n  * adds in `initialState`s\n\n  @class Transition\n  @private\n*/\nvar Transition = function(raw) {\n  this.enterStates = raw.enterStates.slice();\n  this.exitStates = raw.exitStates.slice();\n  this.resolveState = raw.resolveState;\n\n  this.finalState = raw.enterStates[raw.enterStates.length - 1] || raw.resolveState;\n};\n\nTransition.prototype = {\n  /**\n    Normalize the passed in enter, exit and resolve states.\n\n    This process also adds `finalState` and `contexts` to the Transition object.\n\n    @method normalize\n    @param {Ember.StateManager} manager the state manager running the transition\n    @param {Array} contexts a list of contexts passed into `transitionTo`\n  */\n  normalize: function(manager, contexts) {\n    this.matchContextsToStates(contexts);\n    this.addInitialStates();\n    this.removeUnchangedContexts(manager);\n    return this;\n  },\n\n  /**\n    Match each of the contexts passed to `transitionTo` to a state.\n    This process may also require adding additional enter and exit\n    states if there are more contexts than enter states.\n\n    @method matchContextsToStates\n    @param {Array} contexts a list of contexts passed into `transitionTo`\n  */\n  matchContextsToStates: function(contexts) {\n    var stateIdx = this.enterStates.length - 1,\n        matchedContexts = [],\n        state,\n        context;\n\n    // Next, we will match the passed in contexts to the states they\n    // represent.\n    //\n    // First, assign a context to each enter state in reverse order. If\n    // any contexts are left, add a parent state to the list of states\n    // to enter and exit, and assign a context to the parent state.\n    //\n    // If there are still contexts left when the state manager is\n    // reached, raise an exception.\n    //\n    // This allows the following:\n    //\n    // |- root\n    // | |- post\n    // | | |- comments\n    // | |- about (* current state)\n    //\n    // For `transitionTo('post.comments', post, post.get('comments')`,\n    // the first context (`post`) will be assigned to `root.post`, and\n    // the second context (`post.get('comments')`) will be assigned\n    // to `root.post.comments`.\n    //\n    // For the following:\n    //\n    // |- root\n    // | |- post\n    // | | |- index (* current state)\n    // | | |- comments\n    //\n    // For `transitionTo('post.comments', otherPost, otherPost.get('comments')`,\n    // the `<root.post>` state will be added to the list of enter and exit\n    // states because its context has changed.\n\n    while (contexts.length > 0) {\n      if (stateIdx >= 0) {\n        state = this.enterStates[stateIdx--];\n      } else {\n        if (this.enterStates.length) {\n          state = get(this.enterStates[0], 'parentState');\n          if (!state) { throw \"Cannot match all contexts to states\"; }\n        } else {\n          // If re-entering the current state with a context, the resolve\n          // state will be the current state.\n          state = this.resolveState;\n        }\n\n        this.enterStates.unshift(state);\n        this.exitStates.unshift(state);\n      }\n\n      // in routers, only states with dynamic segments have a context\n      if (get(state, 'hasContext')) {\n        context = contexts.pop();\n      } else {\n        context = null;\n      }\n\n      matchedContexts.unshift(context);\n    }\n\n    this.contexts = matchedContexts;\n  },\n\n  /**\n    Add any `initialState`s to the list of enter states.\n\n    @method addInitialStates\n  */\n  addInitialStates: function() {\n    var finalState = this.finalState, initialState;\n\n    while(true) {\n      initialState = get(finalState, 'initialState') || 'start';\n      finalState = get(finalState, 'states.' + initialState);\n\n      if (!finalState) { break; }\n\n      this.finalState = finalState;\n      this.enterStates.push(finalState);\n      this.contexts.push(undefined);\n    }\n  },\n\n  /**\n    Remove any states that were added because the number of contexts\n    exceeded the number of explicit enter states, but the context has\n    not changed since the last time the state was entered.\n\n    @method removeUnchangedContexts\n    @param {Ember.StateManager} manager passed in to look up the last\n      context for a state\n  */\n  removeUnchangedContexts: function(manager) {\n    // Start from the beginning of the enter states. If the state was added\n    // to the list during the context matching phase, make sure the context\n    // has actually changed since the last time the state was entered.\n    while (this.enterStates.length > 0) {\n      if (this.enterStates[0] !== this.exitStates[0]) { break; }\n\n      if (this.enterStates.length === this.contexts.length) {\n        if (manager.getStateMeta(this.enterStates[0], 'context') !== this.contexts[0]) { break; }\n        this.contexts.shift();\n      }\n\n      this.resolveState = this.enterStates.shift();\n      this.exitStates.shift();\n    }\n  }\n};\n\n\n/**\n  Sends the event to the currentState, if the event is not handled this method \n  will proceed to call the parentState recursively until it encounters an \n  event handler or reaches the top or root of the state path hierarchy.\n\n  @method sendRecursively\n  @param event\n  @param currentState\n  @param isUnhandledPass\n*/\nvar sendRecursively = function(event, currentState, isUnhandledPass) {\n  var log = this.enableLogging,\n      eventName = isUnhandledPass ? 'unhandledEvent' : event,\n      action = currentState[eventName],\n      contexts, sendRecursiveArguments, actionArguments;\n\n  contexts = [].slice.call(arguments, 3);\n\n  // Test to see if the action is a method that\n  // can be invoked. Don't blindly check just for\n  // existence, because it is possible the state\n  // manager has a child state of the given name,\n  // and we should still raise an exception in that\n  // case.\n  if (typeof action === 'function') {\n    if (log) {\n      if (isUnhandledPass) {\n        Ember.Logger.log(fmt(\"STATEMANAGER: Unhandled event '%@' being sent to state %@.\", [event, get(currentState, 'path')]));\n      } else {\n        Ember.Logger.log(fmt(\"STATEMANAGER: Sending event '%@' to state %@.\", [event, get(currentState, 'path')]));\n      }\n    }\n\n    actionArguments = contexts;\n    if (isUnhandledPass) {\n      actionArguments.unshift(event);\n    }\n    actionArguments.unshift(this);\n\n    return action.apply(currentState, actionArguments);\n  } else {\n    var parentState = get(currentState, 'parentState');\n    if (parentState) {\n\n      sendRecursiveArguments = contexts;\n      sendRecursiveArguments.unshift(event, parentState, isUnhandledPass);\n\n      return sendRecursively.apply(this, sendRecursiveArguments);\n    } else if (!isUnhandledPass) {\n      return sendEvent.call(this, event, contexts, true);\n    }\n  }\n};\n\n/**\n  Send an event to the currentState.\n  \n  @method sendEvent\n  @param eventName\n  @param sendRecursiveArguments\n  @param isUnhandledPass\n*/\nvar sendEvent = function(eventName, sendRecursiveArguments, isUnhandledPass) {\n  sendRecursiveArguments.unshift(eventName, get(this, 'currentState'), isUnhandledPass);\n  return sendRecursively.apply(this, sendRecursiveArguments);\n};\n\n/**\n  StateManager is part of Ember's implementation of a finite state machine. A\n  StateManager instance manages a number of properties that are instances of\n  `Ember.State`,\n  tracks the current active state, and triggers callbacks when states have changed.\n\n  ## Defining States\n\n  The states of StateManager can be declared in one of two ways. First, you can\n  define a `states` property that contains all the states:\n\n  ```javascript\n  var managerA = Ember.StateManager.create({\n    states: {\n      stateOne: Ember.State.create(),\n      stateTwo: Ember.State.create()\n    }\n  });\n\n  managerA.get('states');\n  // {\n  //   stateOne: Ember.State.create(),\n  //   stateTwo: Ember.State.create()\n  // }\n  ```\n\n  You can also add instances of `Ember.State` (or an `Ember.State` subclass)\n  directly as properties of a StateManager. These states will be collected into\n  the `states` property for you.\n\n  ```javascript\n  var managerA = Ember.StateManager.create({\n    stateOne: Ember.State.create(),\n    stateTwo: Ember.State.create()\n  });\n\n  managerA.get('states');\n  // {\n  //   stateOne: Ember.State.create(),\n  //   stateTwo: Ember.State.create()\n  // }\n  ```\n\n  ## The Initial State\n\n  When created, a StateManager instance will immediately enter into the state\n  defined as its `start` property or the state referenced by name in its\n  `initialState` property:\n\n  ```javascript\n  var managerA = Ember.StateManager.create({\n    start: Ember.State.create({})\n  });\n\n  managerA.get('currentState.name'); // 'start'\n\n  var managerB = Ember.StateManager.create({\n    initialState: 'beginHere',\n    beginHere: Ember.State.create({})\n  });\n\n  managerB.get('currentState.name'); // 'beginHere'\n  ```\n\n  Because it is a property you may also provide a computed function if you wish\n  to derive an `initialState` programmatically:\n\n  ```javascript\n  var managerC = Ember.StateManager.create({\n    initialState: function() {\n      if (someLogic) {\n        return 'active';\n      } else {\n        return 'passive';\n      }\n    }.property(),\n    active: Ember.State.create({}),\n    passive: Ember.State.create({})\n  });\n  ```\n\n  ## Moving Between States\n\n  A StateManager can have any number of `Ember.State` objects as properties\n  and can have a single one of these states as its current state.\n\n  Calling `transitionTo` transitions between states:\n\n  ```javascript\n  var robotManager = Ember.StateManager.create({\n    initialState: 'poweredDown',\n    poweredDown: Ember.State.create({}),\n    poweredUp: Ember.State.create({})\n  });\n\n  robotManager.get('currentState.name'); // 'poweredDown'\n  robotManager.transitionTo('poweredUp');\n  robotManager.get('currentState.name'); // 'poweredUp'\n  ```\n\n  Before transitioning into a new state the existing `currentState` will have\n  its `exit` method called with the StateManager instance as its first argument\n  and an object representing the transition as its second argument.\n\n  After transitioning into a new state the new `currentState` will have its\n  `enter` method called with the StateManager instance as its first argument\n  and an object representing the transition as its second argument.\n\n  ```javascript\n  var robotManager = Ember.StateManager.create({\n    initialState: 'poweredDown',\n    poweredDown: Ember.State.create({\n      exit: function(stateManager) {\n        console.log(\"exiting the poweredDown state\")\n      }\n    }),\n    poweredUp: Ember.State.create({\n      enter: function(stateManager) {\n        console.log(\"entering the poweredUp state. Destroy all humans.\")\n      }\n    })\n  });\n\n  robotManager.get('currentState.name'); // 'poweredDown'\n  robotManager.transitionTo('poweredUp');\n\n  // will log\n  // 'exiting the poweredDown state'\n  // 'entering the poweredUp state. Destroy all humans.'\n  ```\n\n  Once a StateManager is already in a state, subsequent attempts to enter that\n  state will not trigger enter or exit method calls. Attempts to transition\n  into a state that the manager does not have will result in no changes in the\n  StateManager's current state:\n\n  ```javascript\n  var robotManager = Ember.StateManager.create({\n    initialState: 'poweredDown',\n    poweredDown: Ember.State.create({\n      exit: function(stateManager) {\n        console.log(\"exiting the poweredDown state\")\n      }\n    }),\n    poweredUp: Ember.State.create({\n      enter: function(stateManager) {\n        console.log(\"entering the poweredUp state. Destroy all humans.\")\n      }\n    })\n  });\n\n  robotManager.get('currentState.name'); // 'poweredDown'\n  robotManager.transitionTo('poweredUp');\n  // will log\n  // 'exiting the poweredDown state'\n  // 'entering the poweredUp state. Destroy all humans.'\n  robotManager.transitionTo('poweredUp'); // no logging, no state change\n\n  robotManager.transitionTo('someUnknownState'); // silently fails\n  robotManager.get('currentState.name'); // 'poweredUp'\n  ```\n\n  Each state property may itself contain properties that are instances of\n  `Ember.State`. The StateManager can transition to specific sub-states in a\n  series of transitionTo method calls or via a single transitionTo with the\n  full path to the specific state. The StateManager will also keep track of the\n  full path to its currentState\n\n  ```javascript\n  var robotManager = Ember.StateManager.create({\n    initialState: 'poweredDown',\n    poweredDown: Ember.State.create({\n      charging: Ember.State.create(),\n      charged: Ember.State.create()\n    }),\n    poweredUp: Ember.State.create({\n      mobile: Ember.State.create(),\n      stationary: Ember.State.create()\n    })\n  });\n\n  robotManager.get('currentState.name'); // 'poweredDown'\n\n  robotManager.transitionTo('poweredUp');\n  robotManager.get('currentState.name'); // 'poweredUp'\n\n  robotManager.transitionTo('mobile');\n  robotManager.get('currentState.name'); // 'mobile'\n\n  // transition via a state path\n  robotManager.transitionTo('poweredDown.charging');\n  robotManager.get('currentState.name'); // 'charging'\n\n  robotManager.get('currentState.path'); // 'poweredDown.charging'\n  ```\n\n  Enter transition methods will be called for each state and nested child state\n  in their hierarchical order. Exit methods will be called for each state and\n  its nested states in reverse hierarchical order.\n\n  Exit transitions for a parent state are not called when entering into one of\n  its child states, only when transitioning to a new section of possible states\n  in the hierarchy.\n\n  ```javascript\n  var robotManager = Ember.StateManager.create({\n    initialState: 'poweredDown',\n    poweredDown: Ember.State.create({\n      enter: function() {},\n      exit: function() {\n        console.log(\"exited poweredDown state\")\n      },\n      charging: Ember.State.create({\n        enter: function() {},\n        exit: function() {}\n      }),\n      charged: Ember.State.create({\n        enter: function() {\n          console.log(\"entered charged state\")\n        },\n        exit: function() {\n          console.log(\"exited charged state\")\n        }\n      })\n    }),\n    poweredUp: Ember.State.create({\n      enter: function() {\n        console.log(\"entered poweredUp state\")\n      },\n      exit: function() {},\n      mobile: Ember.State.create({\n        enter: function() {\n          console.log(\"entered mobile state\")\n        },\n        exit: function() {}\n      }),\n      stationary: Ember.State.create({\n        enter: function() {},\n        exit: function() {}\n      })\n    })\n  });\n\n\n  robotManager.get('currentState.path'); // 'poweredDown'\n  robotManager.transitionTo('charged');\n  // logs 'entered charged state'\n  // but does *not* log  'exited poweredDown state'\n  robotManager.get('currentState.name'); // 'charged\n\n  robotManager.transitionTo('poweredUp.mobile');\n  // logs\n  // 'exited charged state'\n  // 'exited poweredDown state'\n  // 'entered poweredUp state'\n  // 'entered mobile state'\n  ```\n\n  During development you can set a StateManager's `enableLogging` property to\n  `true` to receive console messages of state transitions.\n\n  ```javascript\n  var robotManager = Ember.StateManager.create({\n    enableLogging: true\n  });\n  ```\n\n  ## Managing currentState with Actions\n\n  To control which transitions are possible for a given state, and\n  appropriately handle external events, the StateManager can receive and\n  route action messages to its states via the `send` method. Calling to\n  `send` with an action name will begin searching for a method with the same\n  name starting at the current state and moving up through the parent states\n  in a state hierarchy until an appropriate method is found or the StateManager\n  instance itself is reached.\n\n  If an appropriately named method is found it will be called with the state\n  manager as the first argument and an optional `context` object as the second\n  argument.\n\n  ```javascript\n  var managerA = Ember.StateManager.create({\n    initialState: 'stateOne.substateOne.subsubstateOne',\n    stateOne: Ember.State.create({\n      substateOne: Ember.State.create({\n        anAction: function(manager, context) {\n          console.log(\"an action was called\")\n        },\n        subsubstateOne: Ember.State.create({})\n      })\n    })\n  });\n\n  managerA.get('currentState.name'); // 'subsubstateOne'\n  managerA.send('anAction');\n  // 'stateOne.substateOne.subsubstateOne' has no anAction method\n  // so the 'anAction' method of 'stateOne.substateOne' is called\n  // and logs \"an action was called\"\n  // with managerA as the first argument\n  // and no second argument\n\n  var someObject = {};\n  managerA.send('anAction', someObject);\n  // the 'anAction' method of 'stateOne.substateOne' is called again\n  // with managerA as the first argument and\n  // someObject as the second argument.\n  ```\n\n  If the StateManager attempts to send an action but does not find an appropriately named\n  method in the current state or while moving upwards through the state hierarchy, it will\n  repeat the process looking for a `unhandledEvent` method. If an `unhandledEvent` method is\n  found, it will be called with the original event name as the second argument. If an\n  `unhandledEvent` method is not found, the StateManager will throw a new Ember.Error.\n\n  ```javascript\n  var managerB = Ember.StateManager.create({\n    initialState: 'stateOne.substateOne.subsubstateOne',\n    stateOne: Ember.State.create({\n      substateOne: Ember.State.create({\n        subsubstateOne: Ember.State.create({}),\n        unhandledEvent: function(manager, eventName, context) {\n          console.log(\"got an unhandledEvent with name \" + eventName);\n        }\n      })\n    })\n  });\n\n  managerB.get('currentState.name'); // 'subsubstateOne'\n  managerB.send('anAction');\n  // neither `stateOne.substateOne.subsubstateOne` nor any of it's\n  // parent states have a handler for `anAction`. `subsubstateOne`\n  // also does not have a `unhandledEvent` method, but its parent\n  // state, `substateOne`, does, and it gets fired. It will log\n  // \"got an unhandledEvent with name anAction\"\n  ```\n\n  Action detection only moves upwards through the state hierarchy from the current state.\n  It does not search in other portions of the hierarchy.\n\n  ```javascript\n  var managerC = Ember.StateManager.create({\n    initialState: 'stateOne.substateOne.subsubstateOne',\n    stateOne: Ember.State.create({\n      substateOne: Ember.State.create({\n        subsubstateOne: Ember.State.create({})\n      })\n    }),\n    stateTwo: Ember.State.create({\n      anAction: function(manager, context) {\n        // will not be called below because it is\n        // not a parent of the current state\n      }\n    })\n  });\n\n  managerC.get('currentState.name'); // 'subsubstateOne'\n  managerC.send('anAction');\n  // Error: <Ember.StateManager:ember132> could not\n  // respond to event anAction in state stateOne.substateOne.subsubstateOne.\n  ```\n\n  Inside of an action method the given state should delegate `transitionTo` calls on its\n  StateManager.\n\n  ```javascript\n  var robotManager = Ember.StateManager.create({\n    initialState: 'poweredDown.charging',\n    poweredDown: Ember.State.create({\n      charging: Ember.State.create({\n        chargeComplete: function(manager, context) {\n          manager.transitionTo('charged')\n        }\n      }),\n      charged: Ember.State.create({\n        boot: function(manager, context) {\n          manager.transitionTo('poweredUp')\n        }\n      })\n    }),\n    poweredUp: Ember.State.create({\n      beginExtermination: function(manager, context) {\n        manager.transitionTo('rampaging')\n      },\n      rampaging: Ember.State.create()\n    })\n  });\n\n  robotManager.get('currentState.name'); // 'charging'\n  robotManager.send('boot'); // throws error, no boot action\n                            // in current hierarchy\n  robotManager.get('currentState.name'); // remains 'charging'\n\n  robotManager.send('beginExtermination'); // throws error, no beginExtermination\n                                          // action in current hierarchy\n  robotManager.get('currentState.name');   // remains 'charging'\n\n  robotManager.send('chargeComplete');\n  robotManager.get('currentState.name');   // 'charged'\n\n  robotManager.send('boot');\n  robotManager.get('currentState.name');   // 'poweredUp'\n\n  robotManager.send('beginExtermination', allHumans);\n  robotManager.get('currentState.name');   // 'rampaging'\n  ```\n\n  Transition actions can also be created using the `transitionTo` method of the `Ember.State` class. The\n  following example StateManagers are equivalent:\n\n  ```javascript\n  var aManager = Ember.StateManager.create({\n    stateOne: Ember.State.create({\n      changeToStateTwo: Ember.State.transitionTo('stateTwo')\n    }),\n    stateTwo: Ember.State.create({})\n  });\n\n  var bManager = Ember.StateManager.create({\n    stateOne: Ember.State.create({\n      changeToStateTwo: function(manager, context) {\n        manager.transitionTo('stateTwo', context)\n      }\n    }),\n    stateTwo: Ember.State.create({})\n  });\n  ```\n\n  @class StateManager\n  @namespace Ember\n  @extends Ember.State\n**/\nEmber.StateManager = Ember.State.extend({\n  /**\n    @private\n\n    When creating a new statemanager, look for a default state to transition\n    into. This state can either be named `start`, or can be specified using the\n    `initialState` property.\n\n    @method init\n  */\n  init: function() {\n    this._super();\n\n    set(this, 'stateMeta', Ember.Map.create());\n\n    var initialState = get(this, 'initialState');\n\n    if (!initialState && get(this, 'states.start')) {\n      initialState = 'start';\n    }\n\n    if (initialState) {\n      this.transitionTo(initialState);\n      Ember.assert('Failed to transition to initial state \"' + initialState + '\"', !!get(this, 'currentState'));\n    }\n  },\n\n  /**\n    Return the stateMeta, a hash of possible states. If no items exist in the stateMeta hash\n    this method sets the stateMeta to an empty JavaScript object and returns that instead.\n\n    @method stateMetaFor\n    @param state\n  */\n  stateMetaFor: function(state) {\n    var meta = get(this, 'stateMeta'),\n        stateMeta = meta.get(state);\n\n    if (!stateMeta) {\n      stateMeta = {};\n      meta.set(state, stateMeta);\n    }\n\n    return stateMeta;\n  },\n\n  /**\n    Sets a key value pair on the stateMeta hash.\n\n    @method setStateMeta\n    @param state\n    @param key\n    @param value\n  */\n  setStateMeta: function(state, key, value) {\n    return set(this.stateMetaFor(state), key, value);\n  },\n\n  /**\n    Returns the value of an item in the stateMeta hash at the given key.\n\n    @method getStateMeta\n    @param state\n    @param key\n  */\n  getStateMeta: function(state, key) {\n    return get(this.stateMetaFor(state), key);\n  },\n\n  /**\n    The current state from among the manager's possible states. This property should\n    not be set directly. Use `transitionTo` to move between states by name.\n\n    @property currentState\n    @type Ember.State\n  */\n  currentState: null,\n\n  /**\n   The path of the current state. Returns a string representation of the current\n   state.\n\n   @property currentPath\n   @type String\n  */\n  currentPath: Ember.computed.alias('currentState.path'),\n\n  /**\n    The name of transitionEvent that this stateManager will dispatch\n\n    @property transitionEvent\n    @type String\n    @default 'setup'\n  */\n  transitionEvent: 'setup',\n\n  /**\n    If set to true, `errorOnUnhandledEvents` will cause an exception to be\n    raised if you attempt to send an event to a state manager that is not\n    handled by the current state or any of its parent states.\n\n    @property errorOnUnhandledEvents\n    @type Boolean\n    @default true\n  */\n  errorOnUnhandledEvent: true,\n\n  /**\n    An alias to sendEvent method\n\n    @method send\n    @param event\n  */\n  send: function(event) {\n    var contexts = [].slice.call(arguments, 1);\n    Ember.assert('Cannot send event \"' + event + '\" while currentState is ' + get(this, 'currentState'), get(this, 'currentState'));\n    return sendEvent.call(this, event, contexts, false);\n  },\n\n  /**\n    If errorOnUnhandledEvent is true this event with throw an Ember.Error\n    indicating that the no state could respond to the event passed through the\n    state machine.\n\n    @method unhandledEvent\n    @param manager\n    @param event\n  */\n  unhandledEvent: function(manager, event) {\n    if (get(this, 'errorOnUnhandledEvent')) {\n      throw new Ember.Error(this.toString() + \" could not respond to event \" + event + \" in state \" + get(this, 'currentState.path') + \".\");\n    }\n  },\n\n  /**\n    Finds a state by its state path.\n\n    Example:\n\n    ```javascript\n    var manager = Ember.StateManager.create({\n      root: Ember.State.create({\n        dashboard: Ember.State.create()\n      })\n    });\n\n    manager.getStateByPath(manager, \"root.dashboard\");\n    // returns the dashboard state\n  \n    var aState = manager.getStateByPath(manager, \"root.dashboard\");\n\n    var path = aState.get('path');\n    // path is 'root.dashboard'\n\n    var name = aState.get('name');\n    // name is 'dashboard'\n    ```\n\n    @method getStateByPath\n    @param {Ember.State} root the state to start searching from\n    @param {String} path the state path to follow\n    @return {Ember.State} the state at the end of the path\n  */\n  getStateByPath: function(root, path) {\n    var parts = path.split('.'),\n        state = root;\n\n    for (var i=0, len=parts.length; i<len; i++) {\n      state = get(get(state, 'states'), parts[i]);\n      if (!state) { break; }\n    }\n\n    return state;\n  },\n\n  findStateByPath: function(state, path) {\n    var possible;\n\n    while (!possible && state) {\n      possible = this.getStateByPath(state, path);\n      state = get(state, 'parentState');\n    }\n\n    return possible;\n  },\n\n  /**\n    A state stores its child states in its `states` hash.\n    This code takes a path like `posts.show` and looks\n    up `root.states.posts.states.show`.\n\n    It returns a list of all of the states from the\n    root, which is the list of states to call `enter`\n    on.\n\n    @method getStatesInPath\n    @param root\n    @param path\n  */\n  getStatesInPath: function(root, path) {\n    if (!path || path === \"\") { return undefined; }\n    var parts = path.split('.'),\n        result = [],\n        states,\n        state;\n\n    for (var i=0, len=parts.length; i<len; i++) {\n      states = get(root, 'states');\n      if (!states) { return undefined; }\n      state = get(states, parts[i]);\n      if (state) { root = state; result.push(state); }\n      else { return undefined; }\n    }\n\n    return result;\n  },\n\n  /**\n    Alias for transitionTo.\n    This method applies a transitionTo to the arguments passed into this method. \n\n    @method goToState\n  */\n  goToState: function() {\n    // not deprecating this yet so people don't constantly need to\n    // make trivial changes for little reason.\n    return this.transitionTo.apply(this, arguments);\n  },\n\n  /**\n    Transition to another state within the state machine. If the path is empty returns\n    immediately. This method attempts to get a hash of the enter, exit and resolve states\n    from the existing state cache. Processes the raw state information based on the\n    passed in context. Creates a new transition object and triggers a new setupContext.\n\n    @method transitionTo\n    @param path\n    @param context\n  */\n  transitionTo: function(path, context) {\n    // XXX When is transitionTo called with no path\n    if (Ember.isEmpty(path)) { return; }\n\n    // The ES6 signature of this function is `path, ...contexts`\n    var contexts = context ? Array.prototype.slice.call(arguments, 1) : [],\n        currentState = get(this, 'currentState') || this;\n\n    // First, get the enter, exit and resolve states for the current state\n    // and specified path. If possible, use an existing cache.\n    var hash = this.contextFreeTransition(currentState, path);\n\n    // Next, process the raw state information for the contexts passed in.\n    var transition = new Transition(hash).normalize(this, contexts);\n\n    this.enterState(transition);\n    this.triggerSetupContext(transition);\n  },\n\n  /**\n    Allows you to transition to any other state in the state manager without\n    being constrained by the state hierarchy of the current state path.\n    This method will traverse the state path upwards through its parents until\n    it finds the specified state path. All the transitions are captured during the\n    traversal. \n\n    Caches and returns hash of transitions, which contain the exitSates, enterStates and \n    resolvedState\n\n    @method contextFreeTransition\n    @param currentState\n    @param path\n  */\n  contextFreeTransition: function(currentState, path) {\n    var cache = currentState.getPathsCache(this, path);\n    if (cache) { return cache; }\n\n    var enterStates = this.getStatesInPath(currentState, path),\n        exitStates = [],\n        resolveState = currentState;\n\n    // Walk up the states. For each state, check whether a state matching\n    // the `path` is nested underneath. This will find the closest\n    // parent state containing `path`.\n    //\n    // This allows the user to pass in a relative path. For example, for\n    // the following state hierarchy:\n    //\n    //    | |root\n    //    | |- posts\n    //    | | |- show (* current)\n    //    | |- comments\n    //    | | |- show\n    //\n    // If the current state is `<root.posts.show>`, an attempt to\n    // transition to `comments.show` will match `<root.comments.show>`.\n    //\n    // First, this code will look for root.posts.show.comments.show.\n    // Next, it will look for root.posts.comments.show. Finally,\n    // it will look for `root.comments.show`, and find the state.\n    //\n    // After this process, the following variables will exist:\n    //\n    // * resolveState: a common parent state between the current\n    //   and target state. In the above example, `<root>` is the\n    //   `resolveState`.\n    // * enterStates: a list of all of the states represented\n    //   by the path from the `resolveState`. For example, for\n    //   the path `root.comments.show`, `enterStates` would have\n    //   `[<root.comments>, <root.comments.show>]`\n    // * exitStates: a list of all of the states from the\n    //   `resolveState` to the `currentState`. In the above\n    //   example, `exitStates` would have\n    //   `[<root.posts>`, `<root.posts.show>]`.\n    while (resolveState && !enterStates) {\n      exitStates.unshift(resolveState);\n\n      resolveState = get(resolveState, 'parentState');\n      if (!resolveState) {\n        enterStates = this.getStatesInPath(this, path);\n        if (!enterStates) {\n          Ember.assert('Could not find state for path: \"'+path+'\"');\n          return;\n        }\n      }\n      enterStates = this.getStatesInPath(resolveState, path);\n    }\n\n    // If the path contains some states that are parents of both the\n    // current state and the target state, remove them.\n    //\n    // For example, in the following hierarchy:\n    //\n    // |- root\n    // | |- post\n    // | | |- index (* current)\n    // | | |- show\n    //\n    // If the `path` is `root.post.show`, the three variables will\n    // be:\n    //\n    // * resolveState: `<state manager>`\n    // * enterStates: `[<root>, <root.post>, <root.post.show>]`\n    // * exitStates: `[<root>, <root.post>, <root.post.index>]`\n    //\n    // The goal of this code is to remove the common states, so we\n    // have:\n    //\n    // * resolveState: `<root.post>`\n    // * enterStates: `[<root.post.show>]`\n    // * exitStates: `[<root.post.index>]`\n    //\n    // This avoid unnecessary calls to the enter and exit transitions.\n    while (enterStates.length > 0 && enterStates[0] === exitStates[0]) {\n      resolveState = enterStates.shift();\n      exitStates.shift();\n    }\n\n    // Cache the enterStates, exitStates, and resolveState for the\n    // current state and the `path`.\n    var transitions = {\n      exitStates: exitStates,\n      enterStates: enterStates,\n      resolveState: resolveState\n    };\n\n    currentState.setPathsCache(this, path, transitions);\n\n    return transitions;\n  },\n\n  /**\n    A trigger to setup the state contexts. Each state is setup with\n    an enterState.\n\n    @method triggerSetupContext\n    @param transitions\n  */\n  triggerSetupContext: function(transitions) {\n    var contexts = transitions.contexts,\n        offset = transitions.enterStates.length - contexts.length,\n        enterStates = transitions.enterStates,\n        transitionEvent = get(this, 'transitionEvent');\n\n    Ember.assert(\"More contexts provided than states\", offset >= 0);\n\n    arrayForEach.call(enterStates, function(state, idx) {\n      state.trigger(transitionEvent, this, contexts[idx-offset]);\n    }, this);\n  },\n\n  /**\n    Returns the state instance by name. If state is not found the parentState\n    is returned instead.\n\n    @method getState\n    @param name\n  */\n  getState: function(name) {\n    var state = get(this, name),\n        parentState = get(this, 'parentState');\n\n    if (state) {\n      return state;\n    } else if (parentState) {\n      return parentState.getState(name);\n    }\n  },\n\n  /**\n    Causes a transition from the exitState of one state to the enterState of another\n    state in the state machine. At the end of the transition the currentState is set\n    to the finalState of the transition passed into this method.\n\n    @method enterState\n    @param transition\n  */\n  enterState: function(transition) {\n    var log = this.enableLogging;\n\n    var exitStates = transition.exitStates.slice(0).reverse();\n    arrayForEach.call(exitStates, function(state) {\n      state.trigger('exit', this);\n    }, this);\n\n    arrayForEach.call(transition.enterStates, function(state) {\n      if (log) { Ember.Logger.log(\"STATEMANAGER: Entering \" + get(state, 'path')); }\n      state.trigger('enter', this);\n    }, this);\n\n    set(this, 'currentState', transition.finalState);\n  }\n});\n\n})();\n//@ sourceURL=ember-states/state_manager");